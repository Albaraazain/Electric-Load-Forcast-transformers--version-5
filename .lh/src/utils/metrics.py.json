{
    "sourceFile": "src/utils/metrics.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1733311675740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733339017615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,29 +183,36 @@\n         self,\r\n         dataloader: torch.utils.data.DataLoader\r\n     ) -> Tuple[dict, torch.Tensor, torch.Tensor]:\r\n         \"\"\"\r\n-        Evaluate model on test data\r\n-        \r\n-        Args:\r\n-            dataloader: Test data loader\r\n-            \r\n-        Returns:\r\n-            Tuple of (metrics_dict, all_predictions, all_targets)\r\n+        Evaluate model on test data with memory optimization\r\n         \"\"\"\r\n         self.model.eval()\r\n         predictions = []\r\n         targets = []\r\n         \r\n+        # Process in smaller batches\r\n+        batch_size = 16\r\n+        \r\n         for encoder_inputs, _, target in dataloader:\r\n-            # Generate predictions\r\n-            encoder_inputs = encoder_inputs.to(self.device)\r\n-            pred, _ = self.model(encoder_inputs)\r\n+            # Process data in chunks\r\n+            for i in range(0, len(encoder_inputs), batch_size):\r\n+                chunk_inputs = encoder_inputs[i:i+batch_size].to(self.device)\r\n+                chunk_targets = target[i:i+batch_size]\r\n+                \r\n+                # Generate predictions\r\n+                with torch.cuda.amp.autocast():  # Use mixed precision\r\n+                    with torch.no_grad():\r\n+                        pred, _ = self.model(chunk_inputs)\r\n+                \r\n+                # Store predictions and targets\r\n+                predictions.append(pred.cpu())\r\n+                targets.append(chunk_targets.cpu())\r\n+                \r\n+                # Clean up memory\r\n+                del chunk_inputs, pred\r\n+                torch.cuda.empty_cache()\r\n             \r\n-            # Store predictions and targets\r\n-            predictions.append(pred.cpu())\r\n-            targets.append(target.cpu())\r\n-            \r\n         # Concatenate all predictions and targets\r\n         all_predictions = torch.cat(predictions, dim=0)\r\n         all_targets = torch.cat(targets, dim=0)\r\n         \r\n"
                },
                {
                    "date": 1733343648974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,122 +15,85 @@\n class TimeSeriesMetrics:\r\n     \"\"\"Metrics for evaluating time series forecasting models\"\"\"\r\n     \r\n     @staticmethod\r\n-    def mse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n+    def _reshape_arrays(y_true: torch.Tensor, y_pred: torch.Tensor):\r\n         \"\"\"\r\n-        Mean Squared Error\r\n+        Reshape 3D tensors to 2D arrays for sklearn metrics\r\n         \r\n         Args:\r\n-            y_true: Ground truth values\r\n-            y_pred: Predicted values\r\n+            y_true: Ground truth values [batch, seq_len, features]\r\n+            y_pred: Predicted values [batch, seq_len, features]\r\n             \r\n         Returns:\r\n-            MSE value\r\n+            Tuple of reshaped numpy arrays\r\n         \"\"\"\r\n-        return mean_squared_error(\r\n-            y_true.cpu().numpy(),\r\n-            y_pred.cpu().numpy()\r\n-        )\r\n+        # Convert to numpy if needed\r\n+        if isinstance(y_true, torch.Tensor):\r\n+            y_true = y_true.cpu().numpy()\r\n+        if isinstance(y_pred, torch.Tensor):\r\n+            y_pred = y_pred.cpu().numpy()\r\n+            \r\n+        # Reshape from [batch, seq_len, features] to [batch * seq_len, features]\r\n+        y_true_reshaped = y_true.reshape(-1, y_true.shape[-1])\r\n+        y_pred_reshaped = y_pred.reshape(-1, y_pred.shape[-1])\r\n+        \r\n+        return y_true_reshaped, y_pred_reshaped\r\n     \r\n     @staticmethod\r\n+    def mse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n+        \"\"\"Mean Squared Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        return mean_squared_error(y_true, y_pred)\r\n+    \r\n+    @staticmethod\r\n     def rmse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"\r\n-        Root Mean Squared Error\r\n-        \r\n-        Args:\r\n-            y_true: Ground truth values\r\n-            y_pred: Predicted values\r\n-            \r\n-        Returns:\r\n-            RMSE value\r\n-        \"\"\"\r\n-        return np.sqrt(mean_squared_error(\r\n-            y_true.cpu().numpy(),\r\n-            y_pred.cpu().numpy()\r\n-        ))\r\n+        \"\"\"Root Mean Squared Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        return np.sqrt(mean_squared_error(y_true, y_pred))\r\n     \r\n     @staticmethod\r\n     def mae(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"\r\n-        Mean Absolute Error\r\n-        \r\n-        Args:\r\n-            y_true: Ground truth values\r\n-            y_pred: Predicted values\r\n-            \r\n-        Returns:\r\n-            MAE value\r\n-        \"\"\"\r\n-        return mean_absolute_error(\r\n-            y_true.cpu().numpy(),\r\n-            y_pred.cpu().numpy()\r\n-        )\r\n+        \"\"\"Mean Absolute Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        return mean_absolute_error(y_true, y_pred)\r\n     \r\n     @staticmethod\r\n     def mape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"\r\n-        Mean Absolute Percentage Error\r\n+        \"\"\"Mean Absolute Percentage Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n         \r\n-        Args:\r\n-            y_true: Ground truth values\r\n-            y_pred: Predicted values\r\n-            \r\n-        Returns:\r\n-            MAPE value\r\n-        \"\"\"\r\n-        y_true_np = y_true.cpu().numpy()\r\n-        y_pred_np = y_pred.cpu().numpy()\r\n+        # Avoid division by zero\r\n+        mask = y_true != 0\r\n+        y_true_safe = y_true[mask]\r\n+        y_pred_safe = y_pred[mask]\r\n         \r\n-        # Avoid division by zero\r\n-        mask = y_true_np != 0\r\n-        return np.mean(np.abs((y_true_np[mask] - y_pred_np[mask]) / y_true_np[mask])) * 100\r\n+        return np.mean(np.abs((y_true_safe - y_pred_safe) / y_true_safe)) * 100\r\n     \r\n     @staticmethod\r\n     def smape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"\r\n-        Symmetric Mean Absolute Percentage Error\r\n+        \"\"\"Symmetric Mean Absolute Percentage Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n         \r\n-        Args:\r\n-            y_true: Ground truth values\r\n-            y_pred: Predicted values\r\n-            \r\n-        Returns:\r\n-            SMAPE value\r\n-        \"\"\"\r\n-        y_true_np = y_true.cpu().numpy()\r\n-        y_pred_np = y_pred.cpu().numpy()\r\n+        numerator = np.abs(y_pred - y_true)\r\n+        denominator = (np.abs(y_true) + np.abs(y_pred)) / 2\r\n         \r\n-        numerator = np.abs(y_pred_np - y_true_np)\r\n-        denominator = (np.abs(y_true_np) + np.abs(y_pred_np)) / 2\r\n-        \r\n         # Avoid division by zero\r\n         mask = denominator != 0\r\n         return np.mean(numerator[mask] / denominator[mask]) * 100\r\n     \r\n     @staticmethod\r\n-    def evaluate_all(\r\n-        y_true: torch.Tensor,\r\n-        y_pred: torch.Tensor\r\n-    ) -> dict:\r\n-        \"\"\"\r\n-        Calculate all metrics\r\n-        \r\n-        Args:\r\n-            y_true: Ground truth values\r\n-            y_pred: Predicted values\r\n-            \r\n-        Returns:\r\n-            Dictionary containing all metrics\r\n-        \"\"\"\r\n+    def evaluate_all(y_true: torch.Tensor, y_pred: torch.Tensor) -> dict:\r\n+        \"\"\"Calculate all metrics\"\"\"\r\n         return {\r\n             'mse': TimeSeriesMetrics.mse(y_true, y_pred),\r\n             'rmse': TimeSeriesMetrics.rmse(y_true, y_pred),\r\n             'mae': TimeSeriesMetrics.mae(y_true, y_pred),\r\n             'mape': TimeSeriesMetrics.mape(y_true, y_pred),\r\n             'smape': TimeSeriesMetrics.smape(y_true, y_pred)\r\n         }\r\n-\r\n+        \r\n+        \r\n class ModelEvaluator:\r\n     \"\"\"Handles model evaluation and prediction\"\"\"\r\n     \r\n     def __init__(self, model: torch.nn.Module, device: torch.device):\r\n"
                },
                {
                    "date": 1733343850172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,185 @@\n+\"\"\"\r\n+Evaluation metrics for time series forecasting.\r\n+\r\n+Dependencies:\r\n+- torch>=2.0.1\r\n+- numpy>=1.24.3\r\n+- sklearn>=1.3.0\r\n+\"\"\"\r\n+\r\n+import torch\r\n+import numpy as np\r\n+from typing import Tuple\r\n+from sklearn.metrics import mean_squared_error, mean_absolute_error\r\n+\r\n+class TimeSeriesMetrics:\r\n+    \"\"\"Metrics for evaluating time series forecasting models\"\"\"\r\n+    \r\n+    @staticmethod\r\n+    def _reshape_arrays(y_true: torch.Tensor, y_pred: torch.Tensor):\r\n+        \"\"\"\r\n+        Reshape 3D tensors to 2D arrays for sklearn metrics\r\n+        \r\n+        Args:\r\n+            y_true: Ground truth values [batch, seq_len, features]\r\n+            y_pred: Predicted values [batch, seq_len, features]\r\n+            \r\n+        Returns:\r\n+            Tuple of reshaped numpy arrays\r\n+        \"\"\"\r\n+        # Convert to numpy if needed\r\n+        if isinstance(y_true, torch.Tensor):\r\n+            y_true = y_true.cpu().numpy()\r\n+        if isinstance(y_pred, torch.Tensor):\r\n+            y_pred = y_pred.cpu().numpy()\r\n+            \r\n+        # Reshape from [batch, seq_len, features] to [batch * seq_len, features]\r\n+        y_true_reshaped = y_true.reshape(-1, y_true.shape[-1])\r\n+        y_pred_reshaped = y_pred.reshape(-1, y_pred.shape[-1])\r\n+        \r\n+        return y_true_reshaped, y_pred_reshaped\r\n+    \r\n+    @staticmethod\r\n+    def mse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n+        \"\"\"Mean Squared Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        return mean_squared_error(y_true, y_pred)\r\n+    \r\n+    @staticmethod\r\n+    def rmse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n+        \"\"\"Root Mean Squared Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        return np.sqrt(mean_squared_error(y_true, y_pred))\r\n+    \r\n+    @staticmethod\r\n+    def mae(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n+        \"\"\"Mean Absolute Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        return mean_absolute_error(y_true, y_pred)\r\n+    \r\n+    @staticmethod\r\n+    def mape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n+        \"\"\"Mean Absolute Percentage Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        \r\n+        # Avoid division by zero\r\n+        mask = y_true != 0\r\n+        y_true_safe = y_true[mask]\r\n+        y_pred_safe = y_pred[mask]\r\n+        \r\n+        return np.mean(np.abs((y_true_safe - y_pred_safe) / y_true_safe)) * 100\r\n+    \r\n+    @staticmethod\r\n+    def smape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n+        \"\"\"Symmetric Mean Absolute Percentage Error\"\"\"\r\n+        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n+        \r\n+        numerator = np.abs(y_pred - y_true)\r\n+        denominator = (np.abs(y_true) + np.abs(y_pred)) / 2\r\n+        \r\n+        # Avoid division by zero\r\n+        mask = denominator != 0\r\n+        return np.mean(numerator[mask] / denominator[mask]) * 100\r\n+    \r\n+    @staticmethod\r\n+    def evaluate_all(y_true: torch.Tensor, y_pred: torch.Tensor) -> dict:\r\n+        \"\"\"Calculate all metrics\"\"\"\r\n+        return {\r\n+            'mse': TimeSeriesMetrics.mse(y_true, y_pred),\r\n+            'rmse': TimeSeriesMetrics.rmse(y_true, y_pred),\r\n+            'mae': TimeSeriesMetrics.mae(y_true, y_pred),\r\n+            'mape': TimeSeriesMetrics.mape(y_true, y_pred),\r\n+            'smape': TimeSeriesMetrics.smape(y_true, y_pred)\r\n+        }\r\n+        \r\n+        \r\n+class ModelEvaluator:\r\n+    \"\"\"Handles model evaluation and prediction\"\"\"\r\n+    \r\n+    def __init__(self, model: torch.nn.Module, device: torch.device):\r\n+        \"\"\"\r\n+        Initialize evaluator\r\n+        \r\n+        Args:\r\n+            model: Trained model\r\n+            device: Device to run evaluation on\r\n+        \"\"\"\r\n+        self.model = model\r\n+        self.device = device\r\n+        self.metrics = TimeSeriesMetrics()\r\n+        \r\n+    @torch.no_grad()\r\n+    def predict(\r\n+        self,\r\n+        inputs: torch.Tensor,\r\n+        batch_size: int = 32\r\n+    ) -> torch.Tensor:\r\n+        \"\"\"\r\n+        Generate predictions\r\n+        \r\n+        Args:\r\n+            inputs: Input tensor\r\n+            batch_size: Batch size for prediction\r\n+            \r\n+        Returns:\r\n+            Predictions tensor\r\n+        \"\"\"\r\n+        self.model.eval()\r\n+        predictions = []\r\n+        \r\n+        # Create dataloader for batched prediction\r\n+        dataset = torch.utils.data.TensorDataset(inputs)\r\n+        dataloader = torch.utils.data.DataLoader(\r\n+            dataset,\r\n+            batch_size=batch_size,\r\n+            shuffle=False\r\n+        )\r\n+        \r\n+        for batch in dataloader:\r\n+            batch_input = batch[0].to(self.device)\r\n+            batch_pred, _ = self.model(batch_input)\r\n+            predictions.append(batch_pred.cpu())\r\n+            \r\n+        return torch.cat(predictions, dim=0)\r\n+    \r\n+    def evaluate(\r\n+        self,\r\n+        dataloader: torch.utils.data.DataLoader\r\n+    ) -> Tuple[dict, torch.Tensor, torch.Tensor]:\r\n+        \"\"\"\r\n+        Evaluate model on test data with memory optimization\r\n+        \"\"\"\r\n+        self.model.eval()\r\n+        predictions = []\r\n+        targets = []\r\n+        \r\n+        # Process in smaller batches\r\n+        batch_size = 16\r\n+        \r\n+        for encoder_inputs, _, target in dataloader:\r\n+            # Process data in chunks\r\n+            for i in range(0, len(encoder_inputs), batch_size):\r\n+                chunk_inputs = encoder_inputs[i:i+batch_size].to(self.device)\r\n+                chunk_targets = target[i:i+batch_size]\r\n+                \r\n+                # Generate predictions\r\n+                with torch.cuda.amp.autocast():  # Use mixed precision\r\n+                    with torch.no_grad():\r\n+                        pred, _ = self.model(chunk_inputs)\r\n+                \r\n+                # Store predictions and targets\r\n+                predictions.append(pred.cpu())\r\n+                targets.append(chunk_targets.cpu())\r\n+                \r\n+                # Clean up memory\r\n+                del chunk_inputs, pred\r\n+                torch.cuda.empty_cache()\r\n+            \r\n+        # Concatenate all predictions and targets\r\n+        all_predictions = torch.cat(predictions, dim=0)\r\n+        all_targets = torch.cat(targets, dim=0)\r\n+        \r\n+        # Calculate metrics\r\n+        metrics = self.metrics.evaluate_all(all_targets, all_predictions)\r\n+        \r\n+        return metrics, all_predictions, all_targets\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733344011488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -181,190 +181,5 @@\n         \r\n         # Calculate metrics\r\n         metrics = self.metrics.evaluate_all(all_targets, all_predictions)\r\n         \r\n-        return metrics, all_predictions, all_targets\n-\"\"\"\r\n-Evaluation metrics for time series forecasting.\r\n-\r\n-Dependencies:\r\n-- torch>=2.0.1\r\n-- numpy>=1.24.3\r\n-- sklearn>=1.3.0\r\n-\"\"\"\r\n-\r\n-import torch\r\n-import numpy as np\r\n-from typing import Tuple\r\n-from sklearn.metrics import mean_squared_error, mean_absolute_error\r\n-\r\n-class TimeSeriesMetrics:\r\n-    \"\"\"Metrics for evaluating time series forecasting models\"\"\"\r\n-    \r\n-    @staticmethod\r\n-    def _reshape_arrays(y_true: torch.Tensor, y_pred: torch.Tensor):\r\n-        \"\"\"\r\n-        Reshape 3D tensors to 2D arrays for sklearn metrics\r\n-        \r\n-        Args:\r\n-            y_true: Ground truth values [batch, seq_len, features]\r\n-            y_pred: Predicted values [batch, seq_len, features]\r\n-            \r\n-        Returns:\r\n-            Tuple of reshaped numpy arrays\r\n-        \"\"\"\r\n-        # Convert to numpy if needed\r\n-        if isinstance(y_true, torch.Tensor):\r\n-            y_true = y_true.cpu().numpy()\r\n-        if isinstance(y_pred, torch.Tensor):\r\n-            y_pred = y_pred.cpu().numpy()\r\n-            \r\n-        # Reshape from [batch, seq_len, features] to [batch * seq_len, features]\r\n-        y_true_reshaped = y_true.reshape(-1, y_true.shape[-1])\r\n-        y_pred_reshaped = y_pred.reshape(-1, y_pred.shape[-1])\r\n-        \r\n-        return y_true_reshaped, y_pred_reshaped\r\n-    \r\n-    @staticmethod\r\n-    def mse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"Mean Squared Error\"\"\"\r\n-        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n-        return mean_squared_error(y_true, y_pred)\r\n-    \r\n-    @staticmethod\r\n-    def rmse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"Root Mean Squared Error\"\"\"\r\n-        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n-        return np.sqrt(mean_squared_error(y_true, y_pred))\r\n-    \r\n-    @staticmethod\r\n-    def mae(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"Mean Absolute Error\"\"\"\r\n-        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n-        return mean_absolute_error(y_true, y_pred)\r\n-    \r\n-    @staticmethod\r\n-    def mape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"Mean Absolute Percentage Error\"\"\"\r\n-        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n-        \r\n-        # Avoid division by zero\r\n-        mask = y_true != 0\r\n-        y_true_safe = y_true[mask]\r\n-        y_pred_safe = y_pred[mask]\r\n-        \r\n-        return np.mean(np.abs((y_true_safe - y_pred_safe) / y_true_safe)) * 100\r\n-    \r\n-    @staticmethod\r\n-    def smape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n-        \"\"\"Symmetric Mean Absolute Percentage Error\"\"\"\r\n-        y_true, y_pred = TimeSeriesMetrics._reshape_arrays(y_true, y_pred)\r\n-        \r\n-        numerator = np.abs(y_pred - y_true)\r\n-        denominator = (np.abs(y_true) + np.abs(y_pred)) / 2\r\n-        \r\n-        # Avoid division by zero\r\n-        mask = denominator != 0\r\n-        return np.mean(numerator[mask] / denominator[mask]) * 100\r\n-    \r\n-    @staticmethod\r\n-    def evaluate_all(y_true: torch.Tensor, y_pred: torch.Tensor) -> dict:\r\n-        \"\"\"Calculate all metrics\"\"\"\r\n-        return {\r\n-            'mse': TimeSeriesMetrics.mse(y_true, y_pred),\r\n-            'rmse': TimeSeriesMetrics.rmse(y_true, y_pred),\r\n-            'mae': TimeSeriesMetrics.mae(y_true, y_pred),\r\n-            'mape': TimeSeriesMetrics.mape(y_true, y_pred),\r\n-            'smape': TimeSeriesMetrics.smape(y_true, y_pred)\r\n-        }\r\n-        \r\n-        \r\n-class ModelEvaluator:\r\n-    \"\"\"Handles model evaluation and prediction\"\"\"\r\n-    \r\n-    def __init__(self, model: torch.nn.Module, device: torch.device):\r\n-        \"\"\"\r\n-        Initialize evaluator\r\n-        \r\n-        Args:\r\n-            model: Trained model\r\n-            device: Device to run evaluation on\r\n-        \"\"\"\r\n-        self.model = model\r\n-        self.device = device\r\n-        self.metrics = TimeSeriesMetrics()\r\n-        \r\n-    @torch.no_grad()\r\n-    def predict(\r\n-        self,\r\n-        inputs: torch.Tensor,\r\n-        batch_size: int = 32\r\n-    ) -> torch.Tensor:\r\n-        \"\"\"\r\n-        Generate predictions\r\n-        \r\n-        Args:\r\n-            inputs: Input tensor\r\n-            batch_size: Batch size for prediction\r\n-            \r\n-        Returns:\r\n-            Predictions tensor\r\n-        \"\"\"\r\n-        self.model.eval()\r\n-        predictions = []\r\n-        \r\n-        # Create dataloader for batched prediction\r\n-        dataset = torch.utils.data.TensorDataset(inputs)\r\n-        dataloader = torch.utils.data.DataLoader(\r\n-            dataset,\r\n-            batch_size=batch_size,\r\n-            shuffle=False\r\n-        )\r\n-        \r\n-        for batch in dataloader:\r\n-            batch_input = batch[0].to(self.device)\r\n-            batch_pred, _ = self.model(batch_input)\r\n-            predictions.append(batch_pred.cpu())\r\n-            \r\n-        return torch.cat(predictions, dim=0)\r\n-    \r\n-    def evaluate(\r\n-        self,\r\n-        dataloader: torch.utils.data.DataLoader\r\n-    ) -> Tuple[dict, torch.Tensor, torch.Tensor]:\r\n-        \"\"\"\r\n-        Evaluate model on test data with memory optimization\r\n-        \"\"\"\r\n-        self.model.eval()\r\n-        predictions = []\r\n-        targets = []\r\n-        \r\n-        # Process in smaller batches\r\n-        batch_size = 16\r\n-        \r\n-        for encoder_inputs, _, target in dataloader:\r\n-            # Process data in chunks\r\n-            for i in range(0, len(encoder_inputs), batch_size):\r\n-                chunk_inputs = encoder_inputs[i:i+batch_size].to(self.device)\r\n-                chunk_targets = target[i:i+batch_size]\r\n-                \r\n-                # Generate predictions\r\n-                with torch.cuda.amp.autocast():  # Use mixed precision\r\n-                    with torch.no_grad():\r\n-                        pred, _ = self.model(chunk_inputs)\r\n-                \r\n-                # Store predictions and targets\r\n-                predictions.append(pred.cpu())\r\n-                targets.append(chunk_targets.cpu())\r\n-                \r\n-                # Clean up memory\r\n-                del chunk_inputs, pred\r\n-                torch.cuda.empty_cache()\r\n-            \r\n-        # Concatenate all predictions and targets\r\n-        all_predictions = torch.cat(predictions, dim=0)\r\n-        all_targets = torch.cat(targets, dim=0)\r\n-        \r\n-        # Calculate metrics\r\n-        metrics = self.metrics.evaluate_all(all_targets, all_predictions)\r\n-        \r\n         return metrics, all_predictions, all_targets\n\\ No newline at end of file\n"
                }
            ],
            "date": 1733311675740,
            "name": "Commit-0",
            "content": "\"\"\"\r\nEvaluation metrics for time series forecasting.\r\n\r\nDependencies:\r\n- torch>=2.0.1\r\n- numpy>=1.24.3\r\n- sklearn>=1.3.0\r\n\"\"\"\r\n\r\nimport torch\r\nimport numpy as np\r\nfrom typing import Tuple\r\nfrom sklearn.metrics import mean_squared_error, mean_absolute_error\r\n\r\nclass TimeSeriesMetrics:\r\n    \"\"\"Metrics for evaluating time series forecasting models\"\"\"\r\n    \r\n    @staticmethod\r\n    def mse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n        \"\"\"\r\n        Mean Squared Error\r\n        \r\n        Args:\r\n            y_true: Ground truth values\r\n            y_pred: Predicted values\r\n            \r\n        Returns:\r\n            MSE value\r\n        \"\"\"\r\n        return mean_squared_error(\r\n            y_true.cpu().numpy(),\r\n            y_pred.cpu().numpy()\r\n        )\r\n    \r\n    @staticmethod\r\n    def rmse(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n        \"\"\"\r\n        Root Mean Squared Error\r\n        \r\n        Args:\r\n            y_true: Ground truth values\r\n            y_pred: Predicted values\r\n            \r\n        Returns:\r\n            RMSE value\r\n        \"\"\"\r\n        return np.sqrt(mean_squared_error(\r\n            y_true.cpu().numpy(),\r\n            y_pred.cpu().numpy()\r\n        ))\r\n    \r\n    @staticmethod\r\n    def mae(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n        \"\"\"\r\n        Mean Absolute Error\r\n        \r\n        Args:\r\n            y_true: Ground truth values\r\n            y_pred: Predicted values\r\n            \r\n        Returns:\r\n            MAE value\r\n        \"\"\"\r\n        return mean_absolute_error(\r\n            y_true.cpu().numpy(),\r\n            y_pred.cpu().numpy()\r\n        )\r\n    \r\n    @staticmethod\r\n    def mape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n        \"\"\"\r\n        Mean Absolute Percentage Error\r\n        \r\n        Args:\r\n            y_true: Ground truth values\r\n            y_pred: Predicted values\r\n            \r\n        Returns:\r\n            MAPE value\r\n        \"\"\"\r\n        y_true_np = y_true.cpu().numpy()\r\n        y_pred_np = y_pred.cpu().numpy()\r\n        \r\n        # Avoid division by zero\r\n        mask = y_true_np != 0\r\n        return np.mean(np.abs((y_true_np[mask] - y_pred_np[mask]) / y_true_np[mask])) * 100\r\n    \r\n    @staticmethod\r\n    def smape(y_true: torch.Tensor, y_pred: torch.Tensor) -> float:\r\n        \"\"\"\r\n        Symmetric Mean Absolute Percentage Error\r\n        \r\n        Args:\r\n            y_true: Ground truth values\r\n            y_pred: Predicted values\r\n            \r\n        Returns:\r\n            SMAPE value\r\n        \"\"\"\r\n        y_true_np = y_true.cpu().numpy()\r\n        y_pred_np = y_pred.cpu().numpy()\r\n        \r\n        numerator = np.abs(y_pred_np - y_true_np)\r\n        denominator = (np.abs(y_true_np) + np.abs(y_pred_np)) / 2\r\n        \r\n        # Avoid division by zero\r\n        mask = denominator != 0\r\n        return np.mean(numerator[mask] / denominator[mask]) * 100\r\n    \r\n    @staticmethod\r\n    def evaluate_all(\r\n        y_true: torch.Tensor,\r\n        y_pred: torch.Tensor\r\n    ) -> dict:\r\n        \"\"\"\r\n        Calculate all metrics\r\n        \r\n        Args:\r\n            y_true: Ground truth values\r\n            y_pred: Predicted values\r\n            \r\n        Returns:\r\n            Dictionary containing all metrics\r\n        \"\"\"\r\n        return {\r\n            'mse': TimeSeriesMetrics.mse(y_true, y_pred),\r\n            'rmse': TimeSeriesMetrics.rmse(y_true, y_pred),\r\n            'mae': TimeSeriesMetrics.mae(y_true, y_pred),\r\n            'mape': TimeSeriesMetrics.mape(y_true, y_pred),\r\n            'smape': TimeSeriesMetrics.smape(y_true, y_pred)\r\n        }\r\n\r\nclass ModelEvaluator:\r\n    \"\"\"Handles model evaluation and prediction\"\"\"\r\n    \r\n    def __init__(self, model: torch.nn.Module, device: torch.device):\r\n        \"\"\"\r\n        Initialize evaluator\r\n        \r\n        Args:\r\n            model: Trained model\r\n            device: Device to run evaluation on\r\n        \"\"\"\r\n        self.model = model\r\n        self.device = device\r\n        self.metrics = TimeSeriesMetrics()\r\n        \r\n    @torch.no_grad()\r\n    def predict(\r\n        self,\r\n        inputs: torch.Tensor,\r\n        batch_size: int = 32\r\n    ) -> torch.Tensor:\r\n        \"\"\"\r\n        Generate predictions\r\n        \r\n        Args:\r\n            inputs: Input tensor\r\n            batch_size: Batch size for prediction\r\n            \r\n        Returns:\r\n            Predictions tensor\r\n        \"\"\"\r\n        self.model.eval()\r\n        predictions = []\r\n        \r\n        # Create dataloader for batched prediction\r\n        dataset = torch.utils.data.TensorDataset(inputs)\r\n        dataloader = torch.utils.data.DataLoader(\r\n            dataset,\r\n            batch_size=batch_size,\r\n            shuffle=False\r\n        )\r\n        \r\n        for batch in dataloader:\r\n            batch_input = batch[0].to(self.device)\r\n            batch_pred, _ = self.model(batch_input)\r\n            predictions.append(batch_pred.cpu())\r\n            \r\n        return torch.cat(predictions, dim=0)\r\n    \r\n    def evaluate(\r\n        self,\r\n        dataloader: torch.utils.data.DataLoader\r\n    ) -> Tuple[dict, torch.Tensor, torch.Tensor]:\r\n        \"\"\"\r\n        Evaluate model on test data\r\n        \r\n        Args:\r\n            dataloader: Test data loader\r\n            \r\n        Returns:\r\n            Tuple of (metrics_dict, all_predictions, all_targets)\r\n        \"\"\"\r\n        self.model.eval()\r\n        predictions = []\r\n        targets = []\r\n        \r\n        for encoder_inputs, _, target in dataloader:\r\n            # Generate predictions\r\n            encoder_inputs = encoder_inputs.to(self.device)\r\n            pred, _ = self.model(encoder_inputs)\r\n            \r\n            # Store predictions and targets\r\n            predictions.append(pred.cpu())\r\n            targets.append(target.cpu())\r\n            \r\n        # Concatenate all predictions and targets\r\n        all_predictions = torch.cat(predictions, dim=0)\r\n        all_targets = torch.cat(targets, dim=0)\r\n        \r\n        # Calculate metrics\r\n        metrics = self.metrics.evaluate_all(all_targets, all_predictions)\r\n        \r\n        return metrics, all_predictions, all_targets"
        }
    ]
}